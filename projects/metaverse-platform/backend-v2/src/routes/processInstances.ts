import { Router, Request, Response } from 'express';
import { prisma } from '../lib/prisma';
import { asyncHandler, AppError } from '../utils/error';
import { ProcessInstanceCreateInput } from '../types/index';
const router = Router();
router.get('/', asyncHandler(async (req: Request, res: Response) => { const { templateId, status } = req.query; const instances = await prisma.processInstance.findMany({ where: { ...(templateId && { templateId: templateId as string }), ...(status && { status: status as string }) }, include: { template: { select: { id: true, name: true } }, _count: { select: { tasks: true } } }, orderBy: { createdAt: 'desc' } }); res.json({ success: true, data: instances }); }));
router.get('/:id', asyncHandler(async (req: Request, res: Response) => { const instance = await prisma.processInstance.findUnique({ where: { id: req.params.id as string }, include: { template: { include: { business: { select: { id: true, name: true } } } }, tasks: { include: { assignee: { select: { id: true, name: true, avatar: true } } }, orderBy: { createdAt: 'asc' } } } }); if (!instance) throw new AppError('Instance not found', 404); res.json({ success: true, data: instance }); }));
router.post('/', asyncHandler(async (req: Request, res: Response) => {
  const data: ProcessInstanceCreateInput = req.body; if (!data.templateId) throw new AppError('TemplateId required', 400);
  const template = await prisma.processTemplate.findUnique({ where: { id: data.templateId } }); if (!template) throw new AppError('Template not found', 404); if (template.status !== 'published') throw new AppError('Template not published', 400);
  let definition: any; try { definition = JSON.parse(template.definition); } catch { throw new AppError('Invalid definition', 500); }
  const instance = await prisma.processInstance.create({ data: { templateId: data.templateId, data: data.data ? JSON.stringify(data.data) : null, status: 'running', startedAt: new Date() }, include: { template: { select: { id: true, name: true } } } });
  if (definition.tasks && Array.isArray(definition.tasks)) { for (const t of definition.tasks) { await prisma.task.create({ data: { title: t.title || 'Untitled', description: t.description, type: t.type || 'default', priority: t.priority || 'medium', processInstanceId: instance.id, data: t.data ? JSON.stringify(t.data) : null } }); } }
  const full = await prisma.processInstance.findUnique({ where: { id: instance.id }, include: { template: { select: { id: true, name: true } }, tasks: { include: { assignee: { select: { id: true, name: true } } } } } });
  res.status(201).json({ success: true, data: full });
}));
router.patch('/:id/cancel', asyncHandler(async (req: Request, res: Response) => { const instance = await prisma.processInstance.findUnique({ where: { id: req.params.id as string } }); if (!instance) throw new AppError('Instance not found', 404); if (instance.status !== 'running') throw new AppError('Not running', 400); const updated = await prisma.processInstance.update({ where: { id: req.params.id as string }, data: { status: 'cancelled', endedAt: new Date() }, include: { template: { select: { id: true, name: true } }, tasks: true } }); await prisma.task.updateMany({ where: { processInstanceId: req.params.id as string, status: { notIn: ['completed', 'cancelled'] } }, data: { status: 'cancelled' } }); res.json({ success: true, data: updated }); }));
router.patch('/:id/complete', asyncHandler(async (req: Request, res: Response) => { const instance = await prisma.processInstance.findUnique({ where: { id: req.params.id as string }, include: { tasks: true } }); if (!instance) throw new AppError('Instance not found', 404); if (instance.status !== 'running') throw new AppError('Not running', 400); const incomplete = instance.tasks.filter((t: any) => t.status !== 'completed' && t.status !== 'cancelled'); if (incomplete.length > 0) throw new AppError(`${incomplete.length} tasks incomplete`, 400); const updated = await prisma.processInstance.update({ where: { id: req.params.id as string }, data: { status: 'completed', endedAt: new Date() }, include: { template: { select: { id: true, name: true } }, tasks: { include: { assignee: { select: { id: true, name: true } } } } } }); res.json({ success: true, data: updated }); }));
export default router;
